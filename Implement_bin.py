# Python program to implement ECC encryption and decryption on any binary file like image, video, audio, etc.
import secrets
from tinyec import registry, ec
from Crypto.Cipher import AES
import hashlib, secrets, binascii, os

class Key:
    '''
    This class is used to generate public and private key
    '''
    def _init_(self) -> None:    
        '''
        This constructor function initializes the curve.
        It uses secp256r1 by default
        '''
        # self.curve = registry.get_curve('secp256r1')    # Initializes the curve
        self.curve = registry.get_curve('secp256r1')    # Initializes the curve
        self.privateKey = secrets.randbelow(self.curve.field.n)    # Initializes private key
        self.publicKey = self.privateKey * self.curve.g       # Initializes public key
        # self.cipherTextPrivateKey = secrets.randbelow(self.curve.field.n)
        # self.cipherTextPublicKey = self.cipherTextPrivateKey * self.curve.g
        self.cipherTextPrivateKey = None    # For Encryption (Keep private)
        self.cipherTextPublicKey = None    # For Decryption (Give to other person)

    
    def generate_encryption_key(self):
        '''
        This function generates encryption key
        '''
        self.cipherTextPrivateKey = secrets.randbelow(self.curve.field.n)
        # self.cipherTextPublicKey = self.cipherTextPrivateKey * self.curve.g
        # return (self.cipherTextPublicKey.x, self.cipherTextPublicKey.y)
        return self.cipherTextPrivateKey

    # def generate_decryption_key(self, privateKey, cipherTextPublicKey):
    #     '''
    #     This function generates decryption key
    #     '''
    #     self.privateKey = privateKey
    #     self.cipherTextPublicKey = cipherTextPublicKey
    #     self.cipherTextPrivateKey = self.privateKey * self.cipherTextPublicKey
    #     return self.cipherTextPrivateKey.x, self.cipherTextPrivateKey.y

    def compress_point(self, point):
        '''
        Compresses the point
        Converts the given point from Integer Value to Hexadecimal Value
        '''
        return hex(point.x) + hex(point.y % 2)[2:]

    # def ecc_calc_encryption_keys(self):
    #     '''
    #     This function calculates encryption key
    #     Working of function:
    #     1. Generate cipherTextPrivateKey = new random private key. (In this code, it uses secrets module to generate a random private key)
    #     2. Calculate cipherTextPublicKey = cipherTextPrivateKey * G.
    #     3. Calculate the shared secret: sharedECCKey = publicKey * cipherTextPrivateKey.
    #     4. Return both the sharedECCKey + cipherTextPublicKey. Use the sharedECCKey for symmetric encryption. Use the randomly generated cipherTextPublicKey to calculate the decryption key later.
    #     '''
    #     cipherTextPrivateKey = secrets.randbelow(self.curve.field.n)
    #     cipherTextPublicKey = cipherTextPrivateKey * self.curve.g
    #     sharedECCKey = self.publicKey * cipherTextPrivateKey
    #     return (sharedECCKey, cipherTextPublicKey)

    # def ecc_calc_decryption_key(self, cipherTextPublicKey):
    #     '''
    #     This function calculates decrypt key
    #     Working of Function:
    #     1. Calculate the shared secret: sharedECCKey = cipherTextPublicKey * privateKey.
    #     2. Return the sharedECCKey and use it for the decryption.
    #     '''
    #     sharedECCKey = cipherTextPublicKey * self.privateKey
    #     return sharedECCKey

class ECC:
    '''
    This class is used to encrypt/decrypt the data
    '''
    def _init_(self):
        # Initializes the values which is generated by Key classP
        self.curve = registry.get_curve('secp256r1')
        # self.curve = keyClass.curve     
        # self.publicKey = keyClass.publicKey
        # self.privateKey = keyClass.privateKey

    def encrypt_AES_GCM(self, msg, secretKey):
        '''
        The ciphertext is obtained by the symmetric AES-GCM encryption, along with the nonce (random AES initialization vector) and authTag (the MAC code of the encrypted text, obtained by the GCM block mode).
        '''
        aesCipher = AES.new(secretKey, AES.MODE_GCM)
        ciphertext, authTag = aesCipher.encrypt_and_digest(msg)
        return (ciphertext, aesCipher.nonce, authTag)

    def decrypt_AES_GCM(self, ciphertext, nonce, authTag, secretKey):
        '''
        To decrypt the encrypted message, we use the data produced during the encryption { ciphertext, nonce, authTag, cipherTextPublicKey }, along with the decryption privateKey. 
        The result is the decrypted plaintext message. 
        We use authenticated encryption (GCM block mode), so if the decryption key or some other parameter is incorrect, the decryption will fail with an exception.
        '''
        aesCipher = AES.new(secretKey, AES.MODE_GCM, nonce)
        plaintext = aesCipher.decrypt_and_verify(ciphertext, authTag)
        return plaintext

    def ecc_point_to_256_bit_key(self, point):
        sha = hashlib.sha256(int.to_bytes(point.x, 32, 'big'))
        sha.update(int.to_bytes(point.y, 32, 'big'))
        return sha.digest()

    def encrypt_ECC(self, msg, publicKey, cipherTextPrivateKey):
        sharedECCKey = cipherTextPrivateKey * publicKey
        secretKey = self.ecc_point_to_256_bit_key(sharedECCKey)
        ciphertext, nonce, authTag = self.encrypt_AES_GCM(msg, secretKey)
        cipherTextPublicKey = cipherTextPrivateKey * self.curve.g
        return (ciphertext, nonce, authTag, cipherTextPublicKey)

    def decrypt_ECC(self, encrypted, cipherTextPublicKey, privateKey, msgType=0):   # 0 for file, 1 for string
        if(msgType):
            (ciphertext, nonce, authTag, cipherTextPublicKey) = encrypted
        else:
            with open(encrypted, 'rb') as f:
                # test = f.readlines()
                # for i in test:
                #     print(i.strip(), end="\n===\n")
                # return b't'
                content = f.readlines()
                index = 0
                ciphertext = None
                for i in content:
                    index += 1
                    # i = i.strip()
                    if(i.strip() == b'<|END|>'):
                        f.readline()
                        break
                    ciphertext = i if ciphertext == None else ciphertext + i

                nonce = None
                for i in content[index:]:
                    index += 1
                    # i = i.strip()
                    if(i.strip() == b'<|END|>'):
                        f.readline()
                        break
                    nonce = i if nonce == None else nonce + i

                authTag = None
                for i in content[index:]:
                    index += 1
                    # i = i.strip()
                    if(i.strip() == b'<|END|>'):
                        f.readline()
                        break
                    authTag = i if authTag == None else authTag + i

                ciphertext = ciphertext.strip()
                nonce = nonce.strip()
                authTag = authTag.strip()

                # with open("/tmp/authTag.dec", "w") as f:
                #     f.write(f"{str(authTag)}")
                # with open("/tmp/cipherText.dec", "w") as f:
                #     f.write(f"{str(ciphertext)}")
                # with open("/tmp/nonce.dec", "w") as f:
                #     f.write(f"{str(nonce)}")
        sharedECCKey = privateKey * cipherTextPublicKey
        secretKey = self.ecc_point_to_256_bit_key(sharedECCKey)
        plaintext = self.decrypt_AES_GCM(ciphertext, nonce, authTag, secretKey)
        return plaintext


class Run:
    def _init_(self):
        pass

    def help(self):
        print(f'''
        0. Exit
        1. Generate/Regenerate Keys
        2. Encrypt Message
        3. Decrypt Message
        4. Show Encrypted Message
        5. Show Decrypted Message
        99. Help Menu
        ''')

    def keys_help(self):
        print(f'''Keys:
        0. Exit Generating Keys
        1. Show Public Key
        2. Show Private Key
        3. Encryption Keys
        ''')

    def printEncryptedMsgObj(self, obj):
        for i, j in obj.items():
            print(i, ":", j)

if __name__ == '__main__':
    r = Run()

    r.help()
    encryptedMsg = None
    decryptedMsg = None
    while(user_input:=int(input(">>> "))):
        if(user_input == 0):
            r.help()
            continue

        if(user_input == 1):
            k = Key()
            privateKey = k.privateKey
            publicKey = k.publicKey
            # cipherTextPubKey = k.generate_encryption_key()
            # print("Private Key:", privateKey)
            # print("Public Key: " + str(publicKey.x) + "," + str(publicKey.y))
            # r.keys_help()
            # while(inp:=int(input("> "))):
            #     if(inp == 0):
            #         break
            #     elif(inp == 1):
            #         print("Public Key: " + str(k.publicKey.x) + "," + str(k.publicKey.y))
            #     elif(inp == 2):
            #         print("Private Key:", privateKey)
            #     elif(inp == 3):
            #         cipherTextPubKey = k.generate_encryption_key()
            #         print("Cipher Text Private Key: " + str(k.cipherTextPrivateKey) + "\tNote for Yourself (Don't Share this)")
            #         print("Cipher Text Public Key : " + str(cipherTextPubKey[0]) + "," + str(cipherTextPubKey[1]) + "\tShare this with the person you want to send the message to")
            #     # elif(inp == 4):
            #     #     privKey = int(input("Enter Private Key: "))
            #     #     cipTextPubKey = input("Enter Cipher Text Public Key: ").split(",")
            #     #     print("Cipher Text Public Keys:", k.generate_decryption_key(privKey, ec.Point(k.curve, int(cipTextPubKey[0]), int(cipTextPubKey[1]))))
            #     else:
            #         print("Invalid Input")
            print(f'''
            Public Key: {str(publicKey.x)},{str(publicKey.y)}
            Private Key: {privateKey}
                ''')

        elif(user_input == 2):
            e = ECC()
            k = Key()
            cipherTextPrivateKey = k.generate_encryption_key()
            # cipherTextPrivateKey = k.cipherTextPrivateKey

            path = input("Enter file path to be encrypted: ")
            with open(path, "rb") as f:
                msg = f.read()
            pubKey = input("Enter Public Key: ").split(",")
            encryptedMsg = e.encrypt_ECC(msg, ec.Point(e.curve, int(pubKey[0]), int(pubKey[1])), cipherTextPrivateKey)
            
            encryptedMsgObj = {
                'ciphertext': binascii.hexlify(encryptedMsg[0]).decode("ASCII"),
                'nonce': binascii.hexlify(encryptedMsg[1]).decode("ASCII"),
                'authTag': binascii.hexlify(encryptedMsg[2]).decode("ASCII"),
                'cipherTextPublicKey': hex(encryptedMsg[3].x) + hex(encryptedMsg[3].y % 2)[2:]
            }
            print("Message Encrypted Successfully!!!")

            encryptedMsgFilePath = input("Path to save encrypted message: ")
            with open(encryptedMsgFilePath, 'wb') as f:
                f.write(encryptedMsg[0] + os.linesep.encode("utf-8") + "<|END|>".encode("utf-8") + os.linesep.encode("utf-8"))
                f.write(encryptedMsg[1] + os.linesep.encode("utf-8") + "<|END|>".encode("utf-8") + os.linesep.encode("utf-8"))
                f.write(encryptedMsg[2])
            # with open("/tmp/authTag.enc", "w") as f:
            #     f.write(f"{str(encryptedMsg[2])}")
            # with open("/tmp/cipherText.enc", "w") as f:
            #     f.write(f"{str(encryptedMsg[0])}")
            # with open("/tmp/nonce.enc", "w") as f:
            #     f.write(f"{str(encryptedMsg[1])}")

            print("Share These Keys with other person:")
            print("Cipher Text Public Key : " + str(encryptedMsg[3].x) + "," + str(encryptedMsg[3].y))
            # print("Encrypted message saved to " + encryptedMsgFilePath + ".")
            # print("Note Down the following values, it will be used for decryption(Unencrypted Form):")
            # print("Private Key: " + str(privateKey))
            # print("Cipher Text Private Key: " + str(encryptedMsg[4]))

            # if((input("Save To File(y/N): ").lower()) == 'y'):
            #     with open(input("Enter File Name to save keys: "), 'w') as f:
            #         f.write(f"Private Key: {privateKey}\n")
            #         f.write(f"Cipher Text Private Key: {encryptedMsg[4]}\n")
            #         print(f"Keys saved to {f.name}")

        elif(user_input == 3):
            e = ECC()
            cipherTextPubKey = input("Enter Cipher Text Public Key: ").split(",")
            decryptedMsg = e.decrypt_ECC(input("Path to encrypted message: "), ec.Point(e.curve, int(cipherTextPubKey[0]), int(cipherTextPubKey[1])), int(input("Enter Private Key: ")))

            path = input("Filename to Save decrypted message: ")
            with open(path, 'wb') as f:
                f.write(decryptedMsg)

        elif(user_input == 4):
            print("Encrypted Message:", encryptedMsg)

        elif(user_input == 5):
            print("Decrypted Message:", decryptedMsg)


        elif(user_input == 99):
            r.help()

        else:
            print("Invalid Option...")